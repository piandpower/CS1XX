


## while list is > 0

## while list is < block_Size AND length rem > block_size

## for samp in list , 



## sum= 0
## for beat in sample_block.samples[ind]
##          math.sqr(beat- sample_block.samples(other) )
##   sum +=  ^ above
##  sample_block.samples[ind]


## beg=(start_index - num_neighbours) 
## end = (start-index + num_neighbours)+1

## sublst= [(min (beg len(lst) :end]

## 0 <= start_index < len(list_of_replacement_sample_blocks)

## curr_best = first of sublist
## then for best_fit in sublist

##  best_fit compare to target and compare best fit to the curr_best in list to see which better
## replace if necessary then keep going

## return final best fit at end !